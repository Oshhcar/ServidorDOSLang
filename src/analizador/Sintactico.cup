package analizador;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import analizador.ast.*;
import analizador.ast.entorno.Tipo;
import analizador.ast.entorno.Type;
import analizador.ast.expresion.*;
import analizador.ast.expresion.operacion.*;
import analizador.ast.instruccion.*;
import analizador.ast.instruccion.condicionales.*;

parser code
{:
	private AST ast;
	
	public AST getAST(){
		return ast;
	}
	
        private ArrayList<ErrorC> errores = new ArrayList<>();

        public ArrayList<ErrorC> getErrores(){
            return this.errores;
        }

    @Override
    public void syntax_error(Symbol s){
        System.out.println("Error Sintactico en la Linea " + s.left +" Columna "+ s.right + ". Identificador " +s.value + " no reconocido." );
                ErrorC error = new ErrorC("Sintáctico", s.left+1, s.right+1, "Identificador " +s.value + " no reconocido.");
                this.errores.add(error);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s){
        System.out.println("Error Sintactico Fatal en la Linea " + s.left + " Columna "+ s.right +". Identificador " + s.value + " no reconocido.");
		//report_fatal_error("Error sintactico: <"+s.value+">", cur_token);
                ErrorC error = new ErrorC("Sintáctico", s.left+1, s.right+1, "Identificador " +s.value + " no reconocido.");
                this.errores.add(error);
	}
:}

action code
{:

:}

terminal String tstring, tchar, entero, decimal, id, nil_, true_, false_;
terminal puntoycoma, coma, puntos3, puntos2, igual, parIzquierda, parDerecha;
terminal corcheteIzquierda, corcheteDerecha, dospuntos, asignacion, punto;
terminal mas, menos, asterisco, diagonal, potencia, modulo;
terminal mayorque, menorque, mayorigual, menorigual, diferente;
terminal and, nand, nor, or, not;
terminal char_, integer_, real_, string_, word_, boolean_;
terminal program_, uses_, type_, array_, of_, var_, const_, function_, begin_, end_;
terminal procedure_, record_, break_, if_, then_, else_, with_, do_, continue_, exit_;
terminal case_, default_, while_, repeat_, until_, for_, to_, downto_, write_, writeln_, read_;

non terminal INICIO;
non terminal PROGRAM;
non terminal PROGRAM_NAME;
non terminal USES;
non terminal ID_LIST;
non terminal TYPE_PRIMITIVE;
non terminal TYPEDEF;
non terminal TYPE_LIST;
non terminal TYPE;
non terminal TYPE_VALUE;
non terminal TYPE_SPECIFIER;
non terminal DIM_LIST;
non terminal DIM;
non terminal VARDEF;
non terminal VAR_LIST;
non terminal VAR;
non terminal CONSTDEF;
non terminal CONST_LIST;
non terminal CONST;
non terminal PROCEDUREDEF;
non terminal METHOD_LIST;
non terminal METHOD;
non terminal FUNDEF;
non terminal PARAMETERS;
non terminal PARAMETERS_LIST;
non terminal PARAMETER;
non terminal PROCDEF;
non terminal Bloque BLOQUE;
non terminal ArrayList<NodoAST> SENTENCIAS;
non terminal NodoAST SENTENCIA;
non terminal NodoAST STATEMENT;
non terminal WITH_STMT;
non terminal ASSIGNMENT_STMT;
non terminal TARGET;
non terminal BREAK_STMT;
non terminal CONTINUE_STMT;
non terminal EXIT_STMT;
non terminal If IF_STMT;
non terminal CASE_STMT;
non terminal CASE_LIST;
non terminal CASE;
non terminal WHILE_STMT;
non terminal REPEAT_STMT;
non terminal FOR_STMT;
non terminal Write WRITE_STMT;
non terminal READ_STMT;
non terminal EXPRESSION_STMT;
non terminal ArrayList<Expresion> EXPRESSION_LIST;
non terminal Expresion EXPRESSION;
non terminal Expresion OR_EXPR;
non terminal Expresion AND_EXPR;
non terminal Expresion NANDNOR_EXPR;
non terminal Expresion COMPARISON_EQ;
non terminal Expresion COMPARISON;
non terminal Operador COMP_OPERATOR;
non terminal Expresion A_EXPR;
non terminal Expresion M_EXPR;
non terminal Expresion U_EXPR;
non terminal Expresion PRIMARY;
non terminal Expresion ATOM;
non terminal Expresion LITERAL;
non terminal Expresion ENCLOSURE;
non terminal Expresion PARENTH_FORM;
non terminal Expresion ATTRIBUTEREF;
non terminal Expresion ACCESS;
non terminal Expresion CALL;

precedence left else_;

start with INICIO;

INICIO ::= SENTENCIAS:a //PROGRAM
        {: 
            parser.ast = new AST(a); 
            System.out.println("DOCUMENTO OK"); 
        :}
;

PROGRAM ::= PROGRAM_NAME USES TYPEDEF CONSTDEF VARDEF PROCEDUREDEF BLOQUE punto
;

PROGRAM_NAME ::= program_ id:a puntoycoma
        {:
            System.out.println("programa "+a);
        :}
;

USES ::= uses_ ID_LIST puntoycoma
        | {: :}
;

ID_LIST ::= ID_LIST coma id
            | id
;


TYPE_PRIMITIVE ::= char_
                | integer_
                | real_
                | string_
                | word_
                | boolean_
;

TYPEDEF ::= type_ TYPE_LIST
        | {: :}
;

TYPE_LIST ::= TYPE_LIST TYPE
            | TYPE
;

TYPE ::= ID_LIST igual TYPE_VALUE puntoycoma
;

TYPE_VALUE ::= TYPE_SPECIFIER
            | parIzquierda ID_LIST parDerecha
            //| LITERAL puntos3 LITERAL
            | LITERAL puntos3 LITERAL
;

TYPE_SPECIFIER ::= TYPE_PRIMITIVE
                | array_ corcheteIzquierda DIM_LIST corcheteDerecha of_ TYPE_SPECIFIER
                | id
                | record_ VAR_LIST end_
;

DIM_LIST ::= DIM_LIST coma DIM
            | DIM
;

DIM ::= LITERAL puntos2 LITERAL
        //| id puntos2 id
        | id
;

VARDEF ::= var_ VAR_LIST
        | {: :}
;

VAR_LIST ::= VAR_LIST VAR
        | VAR;

VAR ::= ID_LIST dospuntos TYPE_SPECIFIER puntoycoma
        | ID_LIST dospuntos TYPE_SPECIFIER asignacion EXPRESSION puntoycoma
;

CONSTDEF ::= const_ CONST_LIST
        | {: :} 
;

CONST_LIST ::= CONST_LIST CONST
        | CONST;

CONST ::= ID_LIST igual EXPRESSION puntoycoma
;

PROCEDUREDEF ::= {: :}
            | METHOD_LIST
;

METHOD_LIST ::= METHOD_LIST METHOD 
            | METHOD
;

METHOD ::= FUNDEF puntoycoma
        | FUNDEF
        | PROCDEF puntoycoma
        | PROCDEF
;

FUNDEF ::= function_ id PARAMETERS dospuntos TYPE_SPECIFIER puntoycoma VARDEF PROCEDUREDEF BLOQUE 
;

PARAMETERS ::= parIzquierda PARAMETERS_LIST parDerecha
            | {: :}
;

PARAMETERS_LIST ::= PARAMETERS_LIST puntoycoma PARAMETER
                | PARAMETER
;

PARAMETER ::= ID_LIST dospuntos TYPE_SPECIFIER
            | var_ ID_LIST dospuntos TYPE_SPECIFIER
;

PROCDEF ::= procedure_ id PARAMETERS puntoycoma VARDEF PROCEDUREDEF BLOQUE
;

BLOQUE ::= begin_:a SENTENCIAS:b end_ {: RESULT = new Bloque(b, aleft, aright); :}
        | begin_:a end_ {: RESULT = new Bloque(null, aleft, aright); :}
;

STATEMENT ::= BLOQUE:a puntoycoma {: RESULT = a; :}
            | BLOQUE:a {: RESULT = a; :}
            | SENTENCIA:a {: RESULT = a; :}
;

SENTENCIAS ::= SENTENCIAS:a SENTENCIA:b
                {:
                    RESULT = a;
                    RESULT.add(b);
                :}
            | SENTENCIA:a
                {:
                    RESULT = new ArrayList<>();
                    RESULT.add(a);
                :}
;

SENTENCIA ::= WITH_STMT puntoycoma
            | WITH_STMT
            | ASSIGNMENT_STMT puntoycoma
            | BREAK_STMT puntoycoma
            | CONTINUE_STMT puntoycoma
            | EXIT_STMT puntoycoma
            | IF_STMT:a {: RESULT = a; :}
            | CASE_STMT
            | CASE_STMT puntoycoma
            | WHILE_STMT
            | REPEAT_STMT puntoycoma
            | FOR_STMT
            | WRITE_STMT:a puntoycoma {: RESULT = a; :}
            | READ_STMT puntoycoma
            | EXPRESSION_STMT puntoycoma
;

WITH_STMT ::= with_ ID_LIST do_ SENTENCIAS end_ 
            | with_ ID_LIST do_ end_
;

TARGET ::= id
        | ATTRIBUTEREF
        | ACCESS
;

ASSIGNMENT_STMT ::= TARGET asignacion EXPRESSION
;

BREAK_STMT ::= break_
;

CONTINUE_STMT ::= continue_
;

EXIT_STMT ::= exit_
;

IF_STMT ::= if_:a EXPRESSION:b then_ STATEMENT:c else_ STATEMENT:d {: RESULT = new If(b, c, d, aleft, aright); :}
          | if_:a EXPRESSION:b then_ STATEMENT:c {: RESULT = new If(b, c, aleft, aright); :}
;

CASE_STMT ::= case_ EXPRESSION of_ CASE_LIST default_ STATEMENT end_ /*VERIFICAR SI ES ELSE*/
            | case_ EXPRESSION of_ CASE_LIST end_
;

CASE_LIST ::= CASE_LIST CASE
            | CASE
;

CASE ::= EXPRESSION_LIST dospuntos STATEMENT
;

WHILE_STMT ::= while_ EXPRESSION do_ STATEMENT
;

REPEAT_STMT ::= repeat_ SENTENCIAS until_ EXPRESSION
;

FOR_STMT ::= for_ TARGET asignacion EXPRESSION to_ EXPRESSION do_ STATEMENT
            | for_ TARGET asignacion EXPRESSION downto_ EXPRESSION do_ STATEMENT
;

WRITE_STMT ::= write_:a parIzquierda EXPRESSION_LIST:b parDerecha  //agregar en la llamada write y writeln sin nada
                {: RESULT = new Write(false, b, aleft, aright); :}
            | writeln_:a parIzquierda EXPRESSION_LIST:b parDerecha
                {: RESULT = new Write(true, b, aleft, aright); :}
;

READ_STMT ::= read_ parIzquierda EXPRESSION parDerecha
;

EXPRESSION_STMT ::= CALL 
                | id
;

EXPRESSION_LIST ::= EXPRESSION_LIST:a coma EXPRESSION:b {: RESULT = a; RESULT.add(b); :}
                | EXPRESSION:a {: RESULT = new ArrayList<>(); RESULT.add(a); :}
;

EXPRESSION ::= OR_EXPR:a {: RESULT = a; :}
;

OR_EXPR ::= NANDNOR_EXPR:a {: RESULT = a; :}
        | OR_EXPR:a or:b NANDNOR_EXPR:c {: RESULT = new Logica(a, c, Operador.OR, bleft, bright); :}
;

NANDNOR_EXPR ::= AND_EXPR:a {: RESULT = a; :}
                | NANDNOR_EXPR:a nand:b AND_EXPR:c {: RESULT = new Logica(a, c, Operador.NAND, bleft, bright); :}
                | NANDNOR_EXPR:a nor:b AND_EXPR:c {: RESULT = new Logica(a, c, Operador.NOR, bleft, bright); :}
;

AND_EXPR ::= COMPARISON_EQ:a {: RESULT = a; :} 
            | AND_EXPR:a and:b COMPARISON_EQ:c {: RESULT = new Logica(a, c, Operador.AND, bleft, bright); :}
;

COMPARISON_EQ ::= COMPARISON:a {: RESULT = a; :}
            | COMPARISON_EQ:a igual:b COMPARISON:c {: RESULT = new Relacional(a, c, Operador.IGUAL, bleft, bright); :}
            | COMPARISON_EQ:a diferente:b COMPARISON:c {: RESULT = new Relacional(a, c, Operador.DIFERENTE, bleft, bright); :}
;

COMPARISON ::= A_EXPR:a {: RESULT = a; :}
            | COMPARISON:a COMP_OPERATOR:b  A_EXPR:c {: RESULT = new Relacional(a, c, b, bleft, bright); :}
;

COMP_OPERATOR ::= mayorque {: RESULT = Operador.MAYOR; :}
                | menorque {: RESULT = Operador.MENOR; :}
                | mayorigual {: RESULT = Operador.MAYORIGUAL; :}
                | menorigual {: RESULT = Operador.MENORIGUAL; :}
;

A_EXPR ::= M_EXPR:a {: RESULT = a; :} 
        | A_EXPR:a mas:b M_EXPR:c {: RESULT = new Aritmetica(a, c, Operador.SUMA, bleft, bright); :}
        | A_EXPR:a menos:b M_EXPR:c {: RESULT = new Aritmetica(a, c, Operador.RESTA, bleft, bright); :}
;

M_EXPR ::= U_EXPR:a {: RESULT = a; :}
        | M_EXPR:a asterisco:b U_EXPR:c {: RESULT = new Aritmetica(a, c, Operador.MULTIPLICACION, bleft, bright); :}
        | M_EXPR:a diagonal:b U_EXPR:c {: RESULT = new Aritmetica(a, c, Operador.DIVISION, bleft, bright); :}
        | M_EXPR:a modulo:b U_EXPR:c {: RESULT = new Aritmetica(a, c, Operador.MODULO, bleft, bright); :}
        | M_EXPR:a potencia:b U_EXPR:c {: RESULT = new Aritmetica(a, c, Operador.POTENCIA, bleft, bright); :}
;

U_EXPR ::= PRIMARY:a {: RESULT = a; :}
        | mas:b PRIMARY:a {: RESULT = new Unario(a,Operador.SUMA, bleft, bright); :}
        | menos:b PRIMARY:a {: RESULT = new Unario(a, Operador.RESTA, bleft, bright); :}
        | not:b PRIMARY:a {: RESULT = new Unario(a, Operador.NOT, bleft, bright); :}
;

PRIMARY ::= ATOM:a {: RESULT = a; :}
        | ATTRIBUTEREF:a {: RESULT = a; :} 
        | ACCESS:a {: RESULT = a; :} 
        | CALL :a {: RESULT = a; :}
;

ATOM ::= id /*esto puede ser una llamada*/
        | LITERAL:a {: RESULT = a; :}
        | ENCLOSURE:a {: RESULT = a; :}
;

LITERAL ::= tstring:a {: RESULT = new Literal(new Tipo(Type.STRING), a, aleft, aright); :} 
     | tchar:a {: RESULT = new Literal(new Tipo(Type.CHAR), a, aleft, aright); :} 
     | entero:a {: RESULT = new Literal(new Tipo(Type.INTEGER), a, aleft, aright); :}
     | decimal:a {: RESULT = new Literal(new Tipo(Type.REAL), a, aleft, aright); :}
     | nil_:a {: RESULT = new Literal(new Tipo(Type.NIL), null, aleft, aright); :}
     | true_:a {: RESULT = new Literal(new Tipo(Type.BOOLEAN), 1, aleft, aright); :}
     | false_:a {: RESULT = new Literal(new Tipo(Type.BOOLEAN), 0, aleft, aright); :}
;

ENCLOSURE ::= PARENTH_FORM:a {: RESULT = a; :}
;

PARENTH_FORM ::= parIzquierda EXPRESSION:a parDerecha {: RESULT = a; :}
;

ATTRIBUTEREF ::= PRIMARY punto id
;

ACCESS ::= PRIMARY corcheteIzquierda EXPRESSION_LIST corcheteDerecha
;

CALL ::=  id parIzquierda parDerecha
        | id parIzquierda EXPRESSION_LIST parDerecha
;