package analizador;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import analizador.ast.*;
import analizador.ast.entorno.Tipo;
import analizador.ast.entorno.Type;
import analizador.ast.expresion.*;
import analizador.ast.expresion.operacion.*;
import analizador.ast.instruccion.*;
import analizador.ast.instruccion.condicionales.*;
import analizador.ast.instruccion.ciclos.*;

parser code
{:
	private AST ast;
	
	public AST getAST(){
		return ast;
	}
	
        private ArrayList<ErrorC> errores = new ArrayList<>();

        public ArrayList<ErrorC> getErrores(){
            return this.errores;
        }

    @Override
    public void syntax_error(Symbol s){
        System.out.println("Error Sintactico en la Linea " + s.left +" Columna "+ s.right + ". Identificador " +s.value + " no reconocido." );
                ErrorC error = new ErrorC("Sintáctico", s.left+1, s.right+1, "Identificador " +s.value + " no reconocido.");
                this.errores.add(error);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s){
        System.out.println("Error Sintactico Fatal en la Linea " + s.left + " Columna "+ s.right +". Identificador " + s.value + " no reconocido.");
		//report_fatal_error("Error sintactico: <"+s.value+">", cur_token);
                ErrorC error = new ErrorC("Sintáctico", s.left+1, s.right+1, "Identificador " +s.value + " no reconocido.");
                this.errores.add(error);
	}
:}

action code
{:

:}

terminal String tstring, tchar, entero, decimal, id, nil_, true_, false_;
terminal puntoycoma, coma, puntos3, puntos2, igual, parIzquierda, parDerecha;
terminal corcheteIzquierda, corcheteDerecha, dospuntos, asignacion, punto;
terminal mas, menos, asterisco, diagonal, potencia, modulo;
terminal mayorque, menorque, mayorigual, menorigual, diferente;
terminal and, nand, nor, or, not;
terminal char_, integer_, real_, string_, word_, boolean_;
terminal program_, uses_, type_, array_, of_, var_, const_, function_, begin_, end_;
terminal procedure_, record_, break_, if_, then_, else_, with_, do_, continue_, exit_;
terminal case_, default_, while_, repeat_, until_, for_, to_, downto_, write_, writeln_, read_;

non terminal INICIO;
non terminal AST PROGRAM;
non terminal String PROGRAM_NAME;
non terminal ArrayList<String> USES;
non terminal ArrayList<String> ID_LIST;
non terminal Type TYPE_PRIMITIVE;
non terminal ArrayList<TipoDef> TYPEDEF;
non terminal ArrayList<TipoDef> TYPE_LIST;
non terminal TipoDef TYPE;
non terminal Tipo TYPE_VALUE;
non terminal Tipo TYPE_SPECIFIER;
non terminal DIM_LIST;
non terminal DIM;
non terminal ArrayList<VarDef> VARDEF;
non terminal ArrayList<VarDef> VAR_LIST;
non terminal VarDef VAR;
non terminal CONSTDEF;
non terminal CONST_LIST;
non terminal CONST;
non terminal PROCEDUREDEF;
non terminal METHOD_LIST;
non terminal METHOD;
non terminal FUNDEF;
non terminal PARAMETERS;
non terminal PARAMETERS_LIST;
non terminal PARAMETER;
non terminal PROCDEF;
non terminal Bloque BLOQUE;
non terminal ArrayList<NodoAST> SENTENCIAS;
non terminal NodoAST SENTENCIA;
non terminal NodoAST STATEMENT;
non terminal WITH_STMT;
non terminal ASSIGNMENT_STMT;
non terminal TARGET;
non terminal BREAK_STMT;
non terminal CONTINUE_STMT;
non terminal EXIT_STMT;
non terminal If IF_STMT;
non terminal Switch CASE_STMT;
non terminal ArrayList<Case> CASE_LIST;
non terminal Case CASE;
non terminal WHILE_STMT;
non terminal REPEAT_STMT;
non terminal FOR_STMT;
non terminal Write WRITE_STMT;
non terminal READ_STMT;
non terminal EXPRESSION_STMT;
non terminal ArrayList<Expresion> EXPRESSION_LIST;
non terminal Expresion EXPRESSION;
non terminal Expresion OR_EXPR;
non terminal Expresion AND_EXPR;
non terminal Expresion NANDNOR_EXPR;
non terminal Expresion COMPARISON_EQ;
non terminal Expresion COMPARISON;
non terminal Operador COMP_OPERATOR;
non terminal Expresion A_EXPR;
non terminal Expresion M_EXPR;
non terminal Expresion U_EXPR;
non terminal Expresion PRIMARY;
non terminal Expresion ATOM;
non terminal Expresion LITERAL;
non terminal Expresion ENCLOSURE;
non terminal Expresion PARENTH_FORM;
non terminal Expresion ATTRIBUTEREF;
non terminal Expresion ACCESS;
non terminal Expresion CALL;

precedence left else_;

start with INICIO;

INICIO ::= PROGRAM:a
        {: 
            parser.ast = a; 
            System.out.println("DOCUMENTO OK"); 
        :}
;

PROGRAM ::= PROGRAM_NAME:a USES:b TYPEDEF:c CONSTDEF:d VARDEF:e PROCEDUREDEF:f BLOQUE:g punto
        {: RESULT = new AST(a, b, c, e, g.getSentencias()); :}
;

PROGRAM_NAME ::= program_ id:a puntoycoma {: RESULT = a.toLowerCase(); :}
;

USES ::= uses_ ID_LIST:a puntoycoma {: RESULT = a; :}
        | {: RESULT = null; :}
;

ID_LIST ::= ID_LIST:a coma id:b
                {:
                    RESULT = a;
                    RESULT.add(b.toLowerCase());
                :}
            | id:a 
                {:
                    RESULT = new ArrayList<>();
                    RESULT.add(a.toLowerCase());
                :}
;


TYPE_PRIMITIVE ::= char_ {: RESULT = Type.CHAR; :}
                | integer_ {: RESULT = Type.INTEGER; :}
                | real_ {: RESULT = Type.REAL; :}
                | string_ {: RESULT = Type.STRING; :}
                | word_ {: RESULT = Type.WORD; :}
                | boolean_ {: RESULT = Type.BOOLEAN; :}
;

TYPEDEF ::= type_ TYPE_LIST:a {: RESULT = a; :}
        | {: RESULT = null; :}
;

TYPE_LIST ::= TYPE_LIST:a TYPE:b
                {:
                    RESULT = a;
                    RESULT.add(b);
                :}
            | TYPE:a 
                {:
                    RESULT = new ArrayList<>();
                    RESULT.add(a);
                :}
;

TYPE ::= ID_LIST:a igual:b TYPE_VALUE:c puntoycoma {: RESULT = new TipoDef(a, c, bleft, bright); :}
;

TYPE_VALUE ::= TYPE_SPECIFIER:a {: RESULT = a; :}
            | parIzquierda ID_LIST parDerecha
            | LITERAL puntos3 LITERAL
;

TYPE_SPECIFIER ::= TYPE_PRIMITIVE:a {: RESULT = new Tipo(a); :}
                | array_ corcheteIzquierda DIM_LIST corcheteDerecha of_ TYPE_SPECIFIER
                | id:a {: RESULT = new Tipo(a.toLowerCase()); :}
                | record_ VAR_LIST end_
;

DIM_LIST ::= DIM_LIST coma DIM
            | DIM
;

DIM ::= LITERAL puntos2 LITERAL
        //| id puntos2 id
        | id
;

VARDEF ::= var_ VAR_LIST:a {: RESULT = a; :}
        | {: RESULT = null; :}
;

VAR_LIST ::= VAR_LIST:a VAR:b
                {: 
                    RESULT = a;
                    RESULT.add(b);
                :}
            | VAR:a
                {:
                    RESULT = new ArrayList<>();
                    RESULT.add(a);
                :}
;

VAR ::= ID_LIST:a dospuntos:b TYPE_SPECIFIER:c puntoycoma 
            {: RESULT = new VarDef(a, c, bleft, bright); :}
        | ID_LIST:a dospuntos:b TYPE_SPECIFIER:c igual EXPRESSION:d puntoycoma
            {: RESULT = new VarDef(a, c, d, bleft, bright); :}
;

CONSTDEF ::= const_ CONST_LIST
        | {: :} 
;

CONST_LIST ::= CONST_LIST CONST
        | CONST;

CONST ::= ID_LIST igual EXPRESSION puntoycoma
;

PROCEDUREDEF ::= {: :}
            | METHOD_LIST
;

METHOD_LIST ::= METHOD_LIST METHOD 
            | METHOD
;

METHOD ::= FUNDEF puntoycoma
        | FUNDEF
        | PROCDEF puntoycoma
        | PROCDEF
;

FUNDEF ::= function_ id PARAMETERS dospuntos TYPE_SPECIFIER puntoycoma VARDEF PROCEDUREDEF BLOQUE 
;

PARAMETERS ::= parIzquierda PARAMETERS_LIST parDerecha
            | {: :}
;

PARAMETERS_LIST ::= PARAMETERS_LIST puntoycoma PARAMETER
                | PARAMETER
;

PARAMETER ::= ID_LIST dospuntos TYPE_SPECIFIER
            | var_ ID_LIST dospuntos TYPE_SPECIFIER
;

PROCDEF ::= procedure_ id PARAMETERS puntoycoma VARDEF PROCEDUREDEF BLOQUE
;

BLOQUE ::= begin_:a SENTENCIAS:b end_ {: RESULT = new Bloque(b, aleft, aright); :}
        | begin_:a end_ {: RESULT = new Bloque(null, aleft, aright); :}
;

STATEMENT ::= BLOQUE:a puntoycoma {: RESULT = a; :}
            | BLOQUE:a {: RESULT = a; :}
            | SENTENCIA:a {: RESULT = a; :}
;

SENTENCIAS ::= SENTENCIAS:a SENTENCIA:b
                {:
                    RESULT = a;
                    RESULT.add(b);
                :}
            | SENTENCIA:a
                {:
                    RESULT = new ArrayList<>();
                    RESULT.add(a);
                :}
;

SENTENCIA ::= WITH_STMT puntoycoma
            | WITH_STMT
            | ASSIGNMENT_STMT puntoycoma
            | BREAK_STMT puntoycoma
            | CONTINUE_STMT puntoycoma
            | EXIT_STMT puntoycoma
            | IF_STMT:a {: RESULT = a; :}
            | CASE_STMT:a {: RESULT = a; :}
            | CASE_STMT:a puntoycoma {: RESULT = a; :}
            | WHILE_STMT
            | REPEAT_STMT puntoycoma
            | FOR_STMT
            | WRITE_STMT:a puntoycoma {: RESULT = a; :}
            | READ_STMT puntoycoma
            | EXPRESSION_STMT puntoycoma
;

WITH_STMT ::= with_ ID_LIST do_ SENTENCIAS end_ 
            | with_ ID_LIST do_ end_
;

TARGET ::= id
        | ATTRIBUTEREF
        | ACCESS
;

ASSIGNMENT_STMT ::= TARGET asignacion EXPRESSION
;

BREAK_STMT ::= break_
;

CONTINUE_STMT ::= continue_
;

EXIT_STMT ::= exit_
;

IF_STMT ::= if_:a EXPRESSION:b then_ STATEMENT:c else_ STATEMENT:d {: RESULT = new If(b, c, d, aleft, aright); :}
          | if_:a EXPRESSION:b then_ STATEMENT:c {: RESULT = new If(b, c, aleft, aright); :}
;

CASE_STMT ::= case_:a EXPRESSION:b of_ CASE_LIST:c default_ STATEMENT:d end_ {: RESULT = new Switch(b, c, d, aleft, aright); :}
            | case_:a EXPRESSION:b of_ CASE_LIST:c else_ STATEMENT:d end_ {: RESULT = new Switch(b, c, d, aleft, aright); :}
            | case_:a EXPRESSION:b of_ CASE_LIST:c end_ {: RESULT = new Switch(b, c, aleft, aright); :}
;

CASE_LIST ::= CASE_LIST:a CASE:b 
                {:
                    RESULT = a;
                    RESULT.add(b);
                :}
            | CASE:a 
                {:
                    RESULT = new ArrayList<>();
                    RESULT.add(a);
                :}
;

CASE ::= EXPRESSION_LIST:a dospuntos:b STATEMENT:c {: RESULT = new Case(a, c, bleft, bright); :}
;

WHILE_STMT ::= while_:a EXPRESSION:b do_ STATEMENT:c {: RESULT = new While(b, c, aleft, aright); :}
;

REPEAT_STMT ::= repeat_ SENTENCIAS until_ EXPRESSION
;

FOR_STMT ::= for_ TARGET asignacion EXPRESSION to_ EXPRESSION do_ STATEMENT
            | for_ TARGET asignacion EXPRESSION downto_ EXPRESSION do_ STATEMENT
;

WRITE_STMT ::= write_:a parIzquierda EXPRESSION_LIST:b parDerecha  //agregar en la llamada write y writeln sin nada
                {: RESULT = new Write(false, b, aleft, aright); :}
            | writeln_:a parIzquierda EXPRESSION_LIST:b parDerecha
                {: RESULT = new Write(true, b, aleft, aright); :}
;

READ_STMT ::= read_ parIzquierda EXPRESSION parDerecha
;

EXPRESSION_STMT ::= CALL 
                | id
;

EXPRESSION_LIST ::= EXPRESSION_LIST:a coma EXPRESSION:b {: RESULT = a; RESULT.add(b); :}
                | EXPRESSION:a {: RESULT = new ArrayList<>(); RESULT.add(a); :}
;

EXPRESSION ::= OR_EXPR:a {: RESULT = a; :}
;

OR_EXPR ::= NANDNOR_EXPR:a {: RESULT = a; :}
        | OR_EXPR:a or:b NANDNOR_EXPR:c {: RESULT = new Logica(a, c, Operador.OR, bleft, bright); :}
;

NANDNOR_EXPR ::= AND_EXPR:a {: RESULT = a; :}
                | NANDNOR_EXPR:a nand:b AND_EXPR:c {: RESULT = new Logica(a, c, Operador.NAND, bleft, bright); :}
                | NANDNOR_EXPR:a nor:b AND_EXPR:c {: RESULT = new Logica(a, c, Operador.NOR, bleft, bright); :}
;

AND_EXPR ::= COMPARISON_EQ:a {: RESULT = a; :} 
            | AND_EXPR:a and:b COMPARISON_EQ:c {: RESULT = new Logica(a, c, Operador.AND, bleft, bright); :}
;

COMPARISON_EQ ::= COMPARISON:a {: RESULT = a; :}
            | COMPARISON_EQ:a igual:b COMPARISON:c {: RESULT = new Relacional(a, c, Operador.IGUAL, bleft, bright); :}
            | COMPARISON_EQ:a diferente:b COMPARISON:c {: RESULT = new Relacional(a, c, Operador.DIFERENTE, bleft, bright); :}
;

COMPARISON ::= A_EXPR:a {: RESULT = a; :}
            | COMPARISON:a COMP_OPERATOR:b  A_EXPR:c {: RESULT = new Relacional(a, c, b, bleft, bright); :}
;

COMP_OPERATOR ::= mayorque {: RESULT = Operador.MAYOR; :}
                | menorque {: RESULT = Operador.MENOR; :}
                | mayorigual {: RESULT = Operador.MAYORIGUAL; :}
                | menorigual {: RESULT = Operador.MENORIGUAL; :}
;

A_EXPR ::= M_EXPR:a {: RESULT = a; :} 
        | A_EXPR:a mas:b M_EXPR:c {: RESULT = new Aritmetica(a, c, Operador.SUMA, bleft, bright); :}
        | A_EXPR:a menos:b M_EXPR:c {: RESULT = new Aritmetica(a, c, Operador.RESTA, bleft, bright); :}
;

M_EXPR ::= U_EXPR:a {: RESULT = a; :}
        | M_EXPR:a asterisco:b U_EXPR:c {: RESULT = new Aritmetica(a, c, Operador.MULTIPLICACION, bleft, bright); :}
        | M_EXPR:a diagonal:b U_EXPR:c {: RESULT = new Aritmetica(a, c, Operador.DIVISION, bleft, bright); :}
        | M_EXPR:a modulo:b U_EXPR:c {: RESULT = new Aritmetica(a, c, Operador.MODULO, bleft, bright); :}
        | M_EXPR:a potencia:b U_EXPR:c {: RESULT = new Aritmetica(a, c, Operador.POTENCIA, bleft, bright); :}
;

U_EXPR ::= PRIMARY:a {: RESULT = a; :}
        | mas:b PRIMARY:a {: RESULT = new Unario(a,Operador.SUMA, bleft, bright); :}
        | menos:b PRIMARY:a {: RESULT = new Unario(a, Operador.RESTA, bleft, bright); :}
        | not:b PRIMARY:a {: RESULT = new Unario(a, Operador.NOT, bleft, bright); :}
;

PRIMARY ::= ATOM:a {: RESULT = a; :}
        | ATTRIBUTEREF:a {: RESULT = a; :} 
        | ACCESS:a {: RESULT = a; :} 
        | CALL :a {: RESULT = a; :}
;

ATOM ::= id:a {: RESULT = new Identificador(a.toLowerCase(), aleft, aright); :} /*esto puede ser una llamada*/
        | LITERAL:a {: RESULT = a; :}
        | ENCLOSURE:a {: RESULT = a; :}
;

LITERAL ::= tstring:a {: RESULT = new Literal(new Tipo(Type.STRING), a, aleft, aright); :} 
     | tchar:a {: RESULT = new Literal(new Tipo(Type.CHAR), a, aleft, aright); :} 
     | entero:a {: RESULT = new Literal(new Tipo(Type.INTEGER), a, aleft, aright); :}
     | decimal:a {: RESULT = new Literal(new Tipo(Type.REAL), a, aleft, aright); :}
     | nil_:a {: RESULT = new Literal(new Tipo(Type.NIL), null, aleft, aright); :}
     | true_:a {: RESULT = new Literal(new Tipo(Type.BOOLEAN), 1, aleft, aright); :}
     | false_:a {: RESULT = new Literal(new Tipo(Type.BOOLEAN), 0, aleft, aright); :}
;

ENCLOSURE ::= PARENTH_FORM:a {: RESULT = a; :}
;

PARENTH_FORM ::= parIzquierda EXPRESSION:a parDerecha {: RESULT = a; :}
;

ATTRIBUTEREF ::= PRIMARY punto id
;

ACCESS ::= PRIMARY corcheteIzquierda EXPRESSION_LIST corcheteDerecha
;

CALL ::=  id parIzquierda parDerecha
        | id parIzquierda EXPRESSION_LIST parDerecha
;